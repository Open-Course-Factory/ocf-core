default:
  tags:
    - ocf-core

# ============================================================================
# Variables
# ============================================================================

variables:
  # Build configuration
  GO_VERSION: "1.24"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

  # PostgreSQL configuration (shared across test jobs)
  POSTGRES_DB: ocf_test
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: "postgrespass"
  POSTGRES_HOST: postgres
  POSTGRES_PORT: "5432"
  POSTGRES_SSLMODE: disable

# ============================================================================
# Stages
# ============================================================================

stages:
  - check    # Version validation and auto-tagging
  - test     # All test suites (unit, integration, race, auth)
  - build    # Docker image creation on release tags
  - release  # Release creation

# ============================================================================
# Cache Configuration
# ============================================================================

.go_cache:
  cache:
    key: "${CI_COMMIT_REF_SLUG}-go-modules"
    paths:
      - .go/pkg/mod/

# ============================================================================
# Base Job Templates
# ============================================================================

.test_job_base:
  stage: test
  image: golang:${GO_VERSION}
  extends: .go_cache
  before_script:
    - export GOPATH=$CI_PROJECT_DIR/.go
    - export PATH=$PATH:$GOPATH/bin
    - go mod download
    - go install github.com/jstemmer/go-junit-report/v2@latest
  artifacts:
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_PIPELINE_SOURCE == "web"  # Manual trigger
  needs: []  # Run in parallel with other test jobs

.postgres_test_base:
  extends: .test_job_base
  services:
    - postgres
  variables:
    POSTGRES_DB: ocf_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: "postgrespass"
  before_script:
    - export GOPATH=$CI_PROJECT_DIR/.go
    - export PATH=$PATH:$GOPATH/bin
    # Install PostgreSQL client for health checks
    - apt-get update -qq && apt-get install -y -qq postgresql-client
    # Wait for PostgreSQL to be ready
    - chmod +x scripts/ci/wait-for-postgres.sh
    - ./scripts/ci/wait-for-postgres.sh
    # Install Go dependencies
    - go mod download
    - go install github.com/jstemmer/go-junit-report/v2@latest

# ============================================================================
# Check Stage
# ============================================================================

# Check version and auto-tag if changed
# When the VERSION file is updated on main branch, this job:
# 1. Compares VERSION file content with latest git tag
# 2. Creates and pushes a new tag if version changed
# 3. Triggers the build pipeline via the new tag
check:version:
  stage: check
  image: alpine:latest
  before_script:
    - apk add --no-cache git curl jq
    # Configure git for tagging
    - git config --global user.email "ci@ocf.soli.fr"
    - git config --global user.name "OCF CI"
  script:
    - |
      # Get current version from VERSION file
      CURRENT_VERSION=$(cat VERSION | tr -d '[:space:]')
      echo "Current version in code: $CURRENT_VERSION"

      # Get latest tag from REMOTE (not local cache which may be stale)
      echo "ðŸ” Checking remote tags..."
      git fetch --tags --prune-tags  # Sync local tags with remote, remove stale local tags

      # Query remote directly to avoid stale local tags
      REMOTE_TAGS=$(git ls-remote --tags origin | grep -v '\^{}' | cut -d/ -f3 | sort -V)
      LATEST_TAG=$(echo "$REMOTE_TAGS" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | tail -1)

      if [ -z "$LATEST_TAG" ]; then
        LATEST_TAG="v0.0.0"
        echo "No version tags found on remote, using default: $LATEST_TAG"
      else
        echo "Latest tag on remote: $LATEST_TAG"
      fi

      # Also check local tags for comparison
      LOCAL_LATEST=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
      if [ "$LOCAL_LATEST" != "$LATEST_TAG" ]; then
        echo "âš ï¸  Local tag cache mismatch:"
        echo "    Local:  $LOCAL_LATEST"
        echo "    Remote: $LATEST_TAG"
        echo "    Using remote as source of truth"
      fi

      # Remove 'v' prefix if present
      LATEST_VERSION=${LATEST_TAG#v}

      # Check if version changed
      if [ "$CURRENT_VERSION" != "$LATEST_VERSION" ]; then
        echo "ðŸŽ‰ Version changed from $LATEST_VERSION to $CURRENT_VERSION"

        # Check if tag already exists ON REMOTE (not just locally)
        if git ls-remote --tags origin | grep -q "refs/tags/v${CURRENT_VERSION}$"; then
          echo "âš ï¸  Tag v${CURRENT_VERSION} already exists on remote, skipping"
        else
          echo "Creating and pushing tag v$CURRENT_VERSION..."

          # Delete stale local tag if it exists (from previous failed push)
          if git rev-parse "v${CURRENT_VERSION}" >/dev/null 2>&1; then
            echo "ðŸ§¹ Removing stale local tag v${CURRENT_VERSION}..."
            git tag -d "v${CURRENT_VERSION}"
          fi

          # Create annotated tag
          git tag -a "v${CURRENT_VERSION}" -m "Release v${CURRENT_VERSION}"

          # Push tag using token (try CI_PUSH_TOKEN first, fallback to CI_JOB_TOKEN)
          TOKEN=${CI_PUSH_TOKEN:-$CI_JOB_TOKEN}

          # Configure remote with authentication
          git remote set-url origin https://gitlab-ci-token:${TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git

          # Push tag with error handling
          if git push origin "v${CURRENT_VERSION}" 2>&1; then
            echo "âœ… Tag v$CURRENT_VERSION created and pushed successfully"
            echo "â³ A new pipeline will start for the tag..."
          else
            echo "âŒ Failed to push tag v$CURRENT_VERSION"
            echo "âš ï¸  Possible causes:"
            echo "   - CI_PUSH_TOKEN not configured (using CI_JOB_TOKEN which may lack permissions)"
            echo "   - Protected tags not allowing CI to push"
            echo "   - Insufficient token permissions"
            echo ""
            echo "ðŸ’¡ Solution: Configure CI_PUSH_TOKEN in CI/CD variables with write_repository scope"
            exit 1
          fi
        fi
      else
        echo "â„¹ï¸  Version unchanged ($CURRENT_VERSION)"
      fi
  rules:
    # Only auto-tag on main branch to prevent accidental releases from feature branches
    - if: $CI_COMMIT_BRANCH == "main"

# ============================================================================
# Test Stage
# ============================================================================

# Tests core entity management system with both SQLite and PostgreSQL
# Includes: generic repository tests, entity registration, security, integration tests
test:entity-management:
  extends: .postgres_test_base
  script:
    # Compile tests once
    - echo "ðŸ“¦ Compiling tests..."
    - go test -c -o entity_tests.exe ./tests/entityManagement

    # Run SQLite-based tests
    - echo "ðŸ§ª Running SQLite-based tests..."
    - ./entity_tests.exe -test.v -test.timeout=60s -test.run "TestGeneric|TestEntityRegistration|TestSecurity|TestIntegration" 2>&1 | tee sqlite_tests.log

    # Run PostgreSQL-specific tests
    - echo "ðŸ˜ Running PostgreSQL-specific tests..."
    - ./entity_tests.exe -test.v -test.timeout=60s -test.run "TestPostgres" 2>&1 | tee postgres_tests.log

    # Generate coverage and test reports
    - echo "ðŸ“Š Generating coverage and test reports..."
    - go test -v -coverprofile=coverage.out ./tests/entityManagement -timeout=90s 2>&1 | tee full_tests.log
    - cat full_tests.log | go-junit-report -set-exit-code > report.xml

  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'

  artifacts:
    reports:
      junit: report.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.out
    paths:
      - coverage.out
      - report.xml
      - sqlite_tests.log
      - postgres_tests.log
      - full_tests.log
    expire_in: 1 week

# Tests course generation and management functionality
test:courses:
  extends: .test_job_base
  script:
    - echo "ðŸ“š Running course tests..."
    - go test -v -timeout=60s ./tests/courses/... 2>&1 | tee courses_tests.log
    - cat courses_tests.log | go-junit-report -set-exit-code > courses_report.xml

  artifacts:
    reports:
      junit: courses_report.xml
    paths:
      - courses_report.xml
      - courses_tests.log
    expire_in: 1 week

# Quick validation tests (no PostgreSQL required)
# Runs a subset of tests marked with -test.short flag for fast feedback
test:quick:
  extends: .test_job_base
  script:
    - echo "âš¡ Running quick tests..."
    - go test -c -o entity_tests.exe ./tests/entityManagement
    - ./entity_tests.exe -test.v -test.short -test.timeout=30s 2>&1 | tee quick_tests.log
    - cat quick_tests.log | go-junit-report -set-exit-code > quick_report.xml

  artifacts:
    reports:
      junit: quick_report.xml
    paths:
      - quick_report.xml
      - quick_tests.log
    expire_in: 1 week

# Race condition detector
# Compiles and runs tests with Go's race detector to catch concurrency issues
test:race:
  extends: .postgres_test_base
  script:
    - echo "ðŸ Running race detector..."
    - go test -c -race -o entity_tests_race.exe ./tests/entityManagement
    - ./entity_tests_race.exe -test.v -test.timeout=120s 2>&1 | tee race_tests.log
    - cat race_tests.log | go-junit-report -set-exit-code > race_report.xml

  artifacts:
    reports:
      junit: race_report.xml
    paths:
      - race_report.xml
      - race_tests.log
    expire_in: 1 week

# Integration tests for Casdoor authentication flow
# Requires: PostgreSQL (app DB), MySQL (Casdoor DB), Casdoor service
# Uses Docker-in-Docker to run all services in isolated network
test:auth:
  stage: test
  # Note: Using custom image would be more efficient, but using base for now
  # To use custom image: registry.gitlab.com/your-project/auth-test:latest
  image: docker:24-dind
  needs: []  # Run in parallel with other test jobs

  services:
    - docker:24-dind

  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: "/certs"
    # PostgreSQL connection via docker network
    POSTGRES_DB: ocf_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: "postgres"
    POSTGRES_HOST: ocf-postgres-test
    POSTGRES_PORT: "5432"
    POSTGRES_SSLMODE: disable
    # Casdoor connection (loaded from .env.test file in container)
    CASDOOR_ENDPOINT: "http://ocf-casdoor-test:8000"

  before_script:
    # Install required tools
    - apk add --no-cache docker-compose postgresql-client wget bash

    # Install Go 1.24 (Alpine's go package is too old)
    - wget https://go.dev/dl/go1.24.1.linux-amd64.tar.gz
    - tar -C /usr/local -xzf go1.24.1.linux-amd64.tar.gz
    - export PATH=$PATH:/usr/local/go/bin
    - export GOPATH=/go
    - export PATH=$PATH:/go/bin
    - go version

    # Create JWT certificate from GitLab CI variable (use test certificate for auth tests)
    - echo $token_jwt_key_test | base64 -d > ./src/auth/casdoor/token_jwt_key.pem

    # Clean up previous run's resources to ensure a fresh start
    - echo "ðŸ§¹ Cleaning up old Docker resources..."
    - docker-compose -f docker-compose.test.yml down -v --remove-orphans || true

    # Start services in order (manual orchestration required)
    - echo "ðŸ³ Starting database services first..."
    - docker-compose -f docker-compose.test.yml up -d postgres-test casdoor-db-test
    - echo "â³ Waiting for databases to initialize..."
    - sleep 15

    # Now start Casdoor after MySQL is ready
    - echo "ðŸ³ Starting Casdoor..."
    - docker-compose -f docker-compose.test.yml up -d casdoor-test
    - echo "â³ Waiting for Casdoor to start..."
    - sleep 10

    # Wait for all services to be ready
    - chmod +x scripts/ci/wait-for-services.sh
    - ./scripts/ci/wait-for-services.sh

    # Install Go dependencies
    - go mod download
    - go install github.com/jstemmer/go-junit-report/v2@latest

  script:
    - echo "ðŸ” Running auth tests..."
    # Run tests inside docker network to access services
    # Note: Casdoor config loaded from .env.test file inside container
    - |
      docker run --rm \
        --network ocf-core_test-network \
        -v $(pwd):/workspace \
        -w /workspace \
        -e POSTGRES_DB=$POSTGRES_DB \
        -e POSTGRES_USER=$POSTGRES_USER \
        -e POSTGRES_PASSWORD=$POSTGRES_PASSWORD \
        -e POSTGRES_HOST=$POSTGRES_HOST \
        -e POSTGRES_PORT=$POSTGRES_PORT \
        -e POSTGRES_SSLMODE=$POSTGRES_SSLMODE \
        -e CASDOOR_ENDPOINT=$CASDOOR_ENDPOINT \
        golang:1.24.1 \
        sh -c "go test -v -timeout=120s ./tests/auth/... 2>&1 | tee auth_tests.log"
    - cat auth_tests.log | go-junit-report -set-exit-code > auth_report.xml

  after_script:
    - docker-compose -f docker-compose.test.yml down -v || true

  artifacts:
    reports:
      junit: auth_report.xml
    paths:
      - auth_report.xml
      - auth_tests.log
    expire_in: 1 week

  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_PIPELINE_SOURCE == "web"  # Manual trigger

# ============================================================================
# Build Stage
# ============================================================================

# Build Docker image and push to registry
# Only runs when version tags are pushed (triggered by check:version job)
# Tags image with both the version number and 'latest'
build:
  stage: build
  before_script:
    - echo $token_jwt_key | base64 -d > ./token_jwt_key.pem
  variables:
    # Add multiple tags: version number + latest
    DOCKER_IMAGE_TAGS: "${CI_COMMIT_TAG#v} latest"
  rules:
    # Only run on version tags (v0.1.0, v1.2.3, etc.)
    - if: $CI_COMMIT_TAG =~ /^v/

# ============================================================================
# Release Stage
# ============================================================================

release:create:
  stage: release
  image: alpine:latest
  variables:
    GITLAB_HOST: "usine.solution-libre.fr"
  before_script:
    - apk add --no-cache git
    - apk add --no-cache glab
  script:
    - export RELEASE_NOTES=$(./scripts/generate-release-notes.sh $CI_COMMIT_TAG)
    - glab release create $CI_COMMIT_TAG -N "$RELEASE_NOTES"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v/

release:manual:
  stage: release
  image: alpine:latest
  variables:
    GITLAB_HOST: $CI_SERVER_HOST
    TAG_NAME: ""
  before_script:
    - apk add --no-cache git
    - apk add --no-cache glab
    - glab auth login --job-token $CI_JOB_TOKEN --hostname $CI_SERVER_HOST --api-protocol $CI_SERVER_PROTOCOL
  script:
    - |
      if [ -z "$TAG_NAME" ]; then
        echo "Please provide a tag name to the TAG_NAME variable."
        exit 1
      fi
    - export RELEASE_NOTES=$(./scripts/generate-release-notes.sh $TAG_NAME)
    - glab release create $TAG_NAME -N "$RELEASE_NOTES"
  when: manual

include:
  - template: Jobs/Build.gitlab-ci.yml
