// src/entityManagement/swagger/specMerger.go
package swagger

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"soli/formations/docs" // G√©n√©r√© par swag init
	ems "soli/formations/src/entityManagement/entityManagementService"
)

// SwaggerSpecMerger combine la documentation swag avec la documentation auto-g√©n√©r√©e
type SwaggerSpecMerger struct {
	docGenerator *DocumentationGenerator
}

func NewSwaggerSpecMerger() *SwaggerSpecMerger {
	return &SwaggerSpecMerger{
		docGenerator: NewDocumentationGenerator(),
	}
}

// MergeSpecs combine les deux sources de documentation
func (sm *SwaggerSpecMerger) MergeSpecs() map[string]interface{} {
	// 1. Cr√©er une spec de base valide
	baseSpec := sm.createValidBaseSpec()

	// 2. Ajouter les sch√©mas manquants communs
	sm.addCommonSchemas(baseSpec)

	// 3. R√©cup√©rer et merger la documentation swag
	swagSpec := sm.getSwagSpecSafely()
	if swagSpec != nil {
		sm.addSwagContent(baseSpec, swagSpec)
	}

	// 4. Ajouter la documentation auto-g√©n√©r√©e
	autoSpec := sm.docGenerator.GenerateOpenAPISpec()
	if autoSpec != nil {
		sm.addAutoGeneratedContent(baseSpec, autoSpec)
	}

	// 5. Convertir les r√©f√©rences Swagger 2.0 vers OpenAPI 3.0
	sm.convertSwagger2References(baseSpec)

	// 6. Valider la spec finale
	sm.validateAndFixSpec(baseSpec)

	log.Printf("‚úÖ Generated valid OpenAPI spec with %d paths",
		len(sm.getPaths(baseSpec)))

	return baseSpec
}

// createValidBaseSpec cr√©e une sp√©cification OpenAPI de base valide
func (sm *SwaggerSpecMerger) createValidBaseSpec() map[string]interface{} {
	serverURL := sm.getServerURL()

	// üö® DEBUG : Log pour v√©rifier l'URL g√©n√©r√©e
	log.Printf("üîç Swagger server URL configured: %s", serverURL)

	return map[string]interface{}{
		"openapi": "3.0.3",
		"info": map[string]interface{}{
			"title":       "OCF API Documentation",
			"version":     sm.getAPIVersion(),
			"description": "API compl√®te pour OCF - Documentation hybride (manuelle + auto-g√©n√©r√©e)",
			"contact": map[string]interface{}{
				"name": "OCF Development Team",
			},
			"x-documentation-type": "hybrid",
			"x-generated-at":       sm.getCurrentTimestamp(),
		},
		"servers": []map[string]interface{}{
			{
				"url":         serverURL,
				"description": "OCF API Server",
			},
		},
		"paths": make(map[string]interface{}),
		"components": map[string]interface{}{
			"schemas": make(map[string]interface{}),
			"securitySchemes": map[string]interface{}{
				"Bearer": map[string]interface{}{
					"type":         "http",
					"scheme":       "bearer",
					"bearerFormat": "JWT",
					"description":  "JWT token for authentication",
				},
			},
		},
		"tags": []map[string]interface{}{},
	}
}

func (sm *SwaggerSpecMerger) getSwagSpecSafely() map[string]interface{} {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("‚ö†Ô∏è  Failed to get swag spec: %v", r)
		}
	}()

	// Essayer de r√©cup√©rer la spec swag
	swagJSON := docs.SwaggerInfo.ReadDoc()
	if swagJSON == "" {
		log.Println("‚ö†Ô∏è  No swag documentation available")
		return nil
	}

	var swagSpec map[string]interface{}
	if err := json.Unmarshal([]byte(swagJSON), &swagSpec); err != nil {
		log.Printf("‚ö†Ô∏è  Failed to unmarshal swag spec: %v", err)
		return nil
	}

	return swagSpec
}

func (sm *SwaggerSpecMerger) addSwagContent(baseSpec map[string]interface{}, swagSpec map[string]interface{}) {
	// 1. Merger les paths de swag
	if swagPaths := sm.getPaths(swagSpec); swagPaths != nil {
		basePaths := sm.getPaths(baseSpec)
		for path, pathSpec := range swagPaths {
			// Ne pas √©craser les paths auto-g√©n√©r√©s
			if !sm.isAutoGeneratedPath(path) {
				basePaths[path] = pathSpec
			}
		}
		log.Printf("üìö Added %d manual paths from swag", len(swagPaths))
	}

	// Merger les sch√©mas de swag
	if swagSchemas := sm.getSchemas(swagSpec); swagSchemas != nil {
		baseSchemas := sm.getSchemas(baseSpec)
		for schemaName, schema := range swagSchemas {
			baseSchemas[schemaName] = schema
		}
		log.Printf("üìö Added %d schemas from swag", len(swagSchemas))
	}

	// Merger les definitions (format swagger 2.0)
	if swagDefinitions := sm.getDefinitions(swagSpec); swagDefinitions != nil {
		baseSchemas := sm.getSchemas(baseSpec)
		for defName, definition := range swagDefinitions {
			// Ne pas √©craser les sch√©mas additionnels d√©j√† ajout√©s
			if _, exists := baseSchemas[defName]; !exists {
				baseSchemas[defName] = sm.convertSwagger2ToOpenAPI3Schema(definition)
			}
		}
		log.Printf("üìö Converted %d definitions from swag to schemas", len(swagDefinitions))
	}

	// 4. Merger les tags
	if swagTags := sm.getTags(swagSpec); swagTags != nil {
		if swagTagsList, ok := swagTags.([]interface{}); ok {
			baseTags := baseSpec["tags"].([]map[string]interface{})
			for _, tag := range swagTagsList {
				if tagMap, ok := tag.(map[string]interface{}); ok {
					baseTags = append(baseTags, tagMap)
				}
			}
			baseSpec["tags"] = baseTags
		}
	}
}

// R√©cup√©rer les sch√©mas depuis components
func (sm *SwaggerSpecMerger) getSchemas(spec map[string]interface{}) map[string]interface{} {
	if components := sm.getComponents(spec); components != nil {
		if schemas, exists := components["schemas"]; exists {
			if schemasMap, ok := schemas.(map[string]interface{}); ok {
				return schemasMap
			}
		}
	}
	return make(map[string]interface{})
}

// R√©cup√©rer les definitions (swagger 2.0)
func (sm *SwaggerSpecMerger) getDefinitions(spec map[string]interface{}) map[string]interface{} {
	if definitions, exists := spec["definitions"]; exists {
		if definitionsMap, ok := definitions.(map[string]interface{}); ok {
			return definitionsMap
		}
	}
	return nil
}

// NOUVELLE M√âTHODE : Convertir d√©finition swagger 2.0 vers sch√©ma OpenAPI 3.0
func (sm *SwaggerSpecMerger) convertSwagger2ToOpenAPI3Schema(definition interface{}) interface{} {
	// Pour l'instant, retourner tel quel car la structure est similaire
	// Dans une version plus avanc√©e, on pourrait convertir les types sp√©cifiques
	return definition
}

func (sm *SwaggerSpecMerger) convertSwagger2References(spec map[string]interface{}) {
	// Convertir r√©cursivement toutes les r√©f√©rences dans la spec
	sm.convertReferencesInMap(spec)
}

func (sm *SwaggerSpecMerger) convertReferencesInMap(obj interface{}) {
	switch v := obj.(type) {
	case map[string]interface{}:
		for key, value := range v {
			if key == "$ref" {
				if refStr, ok := value.(string); ok {
					// Convertir #/definitions/X vers #/components/schemas/X
					if strings.HasPrefix(refStr, "#/definitions/") {
						newRef := strings.Replace(refStr, "#/definitions/", "#/components/schemas/", 1)
						v[key] = newRef
						log.Printf("üîÑ Converted reference: %s -> %s", refStr, newRef)
					}
				}
			} else {
				sm.convertReferencesInMap(value)
			}
		}
	case []interface{}:
		for _, item := range v {
			sm.convertReferencesInMap(item)
		}
	}
}

// Ajouter les sch√©mas communs manquants
func (sm *SwaggerSpecMerger) addCommonSchemas(spec map[string]interface{}) {
	schemas := sm.getSchemas(spec)

	// Utiliser le service de sch√©mas additionnels
	additionalSchemasService := NewAdditionalSchemasService()
	additionalSchemas := additionalSchemasService.GetAllSchemas()
	for schemaName, schema := range additionalSchemas {
		if _, exists := schemas[schemaName]; !exists {
			schemas[schemaName] = schema
			log.Printf("üîß Added schema: %s", schemaName)
		}
	}

	log.Printf("üîß Added %d additional schemas", len(additionalSchemas))
}

// addAutoGeneratedContent ajoute la documentation auto-g√©n√©r√©e
func (sm *SwaggerSpecMerger) addAutoGeneratedContent(baseSpec, autoSpec map[string]interface{}) {
	if autoSpec == nil {
		log.Println("‚ö†Ô∏è  No auto-generated documentation available")
		return
	}

	// Merger les paths auto-g√©n√©r√©s
	if autoPaths := sm.getPaths(autoSpec); autoPaths != nil {
		basePaths := sm.getPaths(baseSpec)
		for path, pathSpec := range autoPaths {
			if _, exists := basePaths[path]; !exists {
				// Marquer comme auto-g√©n√©r√©
				sm.markAsAutoGenerated(pathSpec)
				basePaths[path] = pathSpec
			}
		}
		log.Printf("ü§ñ Added %d auto-generated paths", len(autoPaths))
	}

	// Merger les tags auto-g√©n√©r√©s
	if autoTags := sm.getTags(autoSpec); autoTags != nil {
		if autoTagsList, ok := autoTags.([]interface{}); ok {
			baseTags := baseSpec["tags"].([]map[string]interface{})

			for _, autoTag := range autoTagsList {
				if autoTagMap, ok := autoTag.(map[string]interface{}); ok {
					// V√©rifier si le tag existe d√©j√†
					exists := false
					for _, existingTag := range baseTags {
						if existingTag["name"] == autoTagMap["name"] {
							exists = true
							break
						}
					}

					if !exists {
						autoTagMap["x-auto-generated"] = true
						baseTags = append(baseTags, autoTagMap)
					}
				}
			}
			baseSpec["tags"] = baseTags
		}
	}

	// Merger les sch√©mas auto-g√©n√©r√©s
	if autoSchemas := sm.getSchemas(autoSpec); autoSchemas != nil {
		baseSchemas := sm.getSchemas(baseSpec)
		for schemaName, schema := range autoSchemas {
			if _, exists := baseSchemas[schemaName]; !exists {
				if schemaMap, ok := schema.(map[string]interface{}); ok {
					schemaMap["x-auto-generated"] = true
					baseSchemas[schemaName] = schemaMap
				}
			}
		}
		log.Printf("ü§ñ Added %d auto-generated schemas", len(autoSchemas))
	}

	entityCount := len(ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs())
	log.Printf("ü§ñ Added auto-generated documentation for %d entities", entityCount)
}

// validateAndFixSpec valide et corrige la spec finale
func (sm *SwaggerSpecMerger) validateAndFixSpec(spec map[string]interface{}) {
	// S'assurer que les champs obligatoires existent
	if _, exists := spec["openapi"]; !exists {
		spec["openapi"] = "3.0.3"
		log.Println("üîß Added missing openapi version field")
	}

	if info, exists := spec["info"]; exists {
		if infoMap, ok := info.(map[string]interface{}); ok {
			if _, exists := infoMap["title"]; !exists {
				infoMap["title"] = "OCF API"
				log.Println("üîß Added missing title field")
			}
			if _, exists := infoMap["version"]; !exists {
				infoMap["version"] = "1.0.0"
				log.Println("üîß Added missing version field")
			}
		}
	}

	// S'assurer que paths existe
	if _, exists := spec["paths"]; !exists {
		spec["paths"] = make(map[string]interface{})
		log.Println("üîß Added missing paths field")
	}

	// URL du serveur
	if servers, exists := spec["servers"]; exists {
		if serversList, ok := servers.([]map[string]interface{}); ok {
			for _, server := range serversList {
				if url, exists := server["url"]; exists {
					if urlStr, ok := url.(string); ok {
						// Corriger localhost:// vers http://localhost:
						if strings.Contains(urlStr, "localhost://") {
							server["url"] = strings.Replace(urlStr, "localhost://", "http://localhost:", 1)
							log.Printf("üîß Fixed server URL: %s", server["url"])
						}
					}
				}
			}
		}
	}

	// Ajouter des m√©tadonn√©es sur le processus de merge
	if info, exists := spec["info"]; exists {
		if infoMap, ok := info.(map[string]interface{}); ok {
			infoMap["x-merge-info"] = map[string]interface{}{
				"auto-generated-entities": len(ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs()),
				"manual-paths":            sm.countManualPaths(spec),
				"auto-paths":              sm.countAutoPaths(spec),
				"total-schemas":           len(sm.getSchemas(spec)),
				"generated-at":            sm.getCurrentTimestamp(),
			}
		}
	}
}

// Fonctions utilitaires

func (sm *SwaggerSpecMerger) isAutoGeneratedPath(path string) bool {
	// Les paths auto-g√©n√©r√©s suivent le pattern /entityname ou /entityname/{id}
	autoGeneratedPrefixes := []string{
		"/subscriptionplans",
	}

	for _, prefix := range autoGeneratedPrefixes {
		if path == prefix || path == prefix+"/{id}" {
			return true
		}
	}
	return false
}

func (sm *SwaggerSpecMerger) markAsAutoGenerated(pathSpec interface{}) {
	if pathMap, ok := pathSpec.(map[string]interface{}); ok {
		for _, methodSpec := range pathMap {
			if methodMap, ok := methodSpec.(map[string]interface{}); ok {
				if tags, exists := methodMap["tags"]; exists {
					if tagsList, ok := tags.([]interface{}); ok {
						// Convertir en []string et ajouter le tag auto-generated
						var stringTags []string
						for _, tag := range tagsList {
							if tagStr, ok := tag.(string); ok {
								stringTags = append(stringTags, tagStr)
							}
						}
						stringTags = append(stringTags, "auto-generated")
						methodMap["tags"] = stringTags
					}
				} else {
					methodMap["tags"] = []string{"auto-generated"}
				}
				methodMap["x-auto-generated"] = true
			}
		}
	}
}

func (sm *SwaggerSpecMerger) countManualPaths(spec map[string]interface{}) int {
	count := 0
	if paths := sm.getPaths(spec); paths != nil {
		for _, pathSpec := range paths {
			if !sm.hasAutoGeneratedMarker(pathSpec) {
				count++
			}
		}
	}
	return count
}

func (sm *SwaggerSpecMerger) countAutoPaths(spec map[string]interface{}) int {
	count := 0
	if paths := sm.getPaths(spec); paths != nil {
		for _, pathSpec := range paths {
			if sm.hasAutoGeneratedMarker(pathSpec) {
				count++
			}
		}
	}
	return count
}

func (sm *SwaggerSpecMerger) hasAutoGeneratedMarker(pathSpec interface{}) bool {
	if pathMap, ok := pathSpec.(map[string]interface{}); ok {
		for _, methodSpec := range pathMap {
			if methodMap, ok := methodSpec.(map[string]interface{}); ok {
				if autoGen, exists := methodMap["x-auto-generated"]; exists {
					if autoGenBool, ok := autoGen.(bool); ok && autoGenBool {
						return true
					}
				}
			}
		}
	}
	return false
}

func (sm *SwaggerSpecMerger) getAPIVersion() string {
	if version := os.Getenv("OCF_VERSION"); version != "" {
		return version
	}
	return "1.0.0"
}

func (sm *SwaggerSpecMerger) getServerURL() string {
	if url := os.Getenv("OCF_API_URL"); url != "" {
		return docs.SwaggerInfo.Schemes[0] + "://" + url + "/api/v1"
	}
	return "/api/v1"
}

func (sm *SwaggerSpecMerger) getCurrentTimestamp() string {
	return fmt.Sprintf("%d", time.Now().Unix())
}

// Fonctions utilitaires h√©rit√©es
func (sm *SwaggerSpecMerger) getPaths(spec map[string]interface{}) map[string]interface{} {
	if paths, exists := spec["paths"]; exists {
		if pathsMap, ok := paths.(map[string]interface{}); ok {
			return pathsMap
		}
	}
	return make(map[string]interface{})
}

func (sm *SwaggerSpecMerger) getComponents(spec map[string]interface{}) map[string]interface{} {
	if components, exists := spec["components"]; exists {
		if componentsMap, ok := components.(map[string]interface{}); ok {
			return componentsMap
		}
	}
	return nil
}

func (sm *SwaggerSpecMerger) getTags(spec map[string]interface{}) interface{} {
	if tags, exists := spec["tags"]; exists {
		return tags
	}
	return nil
}

// SwaggerMergeMiddleware permet d'exposer la spec merg√©e
func SwaggerMergeMiddleware() func() map[string]interface{} {
	merger := NewSwaggerSpecMerger()

	return func() map[string]interface{} {
		return merger.MergeSpecs()
	}
}
