// src/entityManagement/swagger/specMerger.go
package swagger

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"soli/formations/docs" // G√©n√©r√© par swag init
	ems "soli/formations/src/entityManagement/entityManagementService"
)

// SwaggerSpecMerger combine la documentation swag avec la documentation auto-g√©n√©r√©e
type SwaggerSpecMerger struct {
	docGenerator *DocumentationGenerator
}

func NewSwaggerSpecMerger() *SwaggerSpecMerger {
	return &SwaggerSpecMerger{
		docGenerator: NewDocumentationGenerator(),
	}
}

// MergeSpecs combine les deux sources de documentation
func (sm *SwaggerSpecMerger) MergeSpecs() map[string]any {
	// 1. Cr√©er une spec de base valide
	baseSpec := sm.createValidBaseSpec()

	// 2. Ajouter les sch√©mas manquants communs
	sm.addCommonSchemas(baseSpec)

	// 3. R√©cup√©rer et merger la documentation swag
	swagSpec := sm.getSwagSpecSafely()
	if swagSpec != nil {
		sm.addSwagContent(baseSpec)
	}

	// 4. Ajouter la documentation auto-g√©n√©r√©e
	autoSpec := sm.docGenerator.GenerateOpenAPISpec()
	if autoSpec != nil {
		sm.addAutoGeneratedContent(baseSpec, autoSpec)
	}

	// 5. Diagnostic et correction des sch√©mas manquants
	sm.diagnoseAndFixSchemaIssues(baseSpec)

	// 5. Convertir les r√©f√©rences Swagger 2.0 vers OpenAPI 3.0
	sm.convertSwagger2References(baseSpec)

	// 6. Valider la spec finale
	sm.validateAndFixSpec(baseSpec)

	log.Printf("‚úÖ Generated valid OpenAPI spec with %d paths",
		len(sm.getPaths(baseSpec)))

	return baseSpec
}

// createValidBaseSpec cr√©e une sp√©cification OpenAPI de base valide
func (sm *SwaggerSpecMerger) createValidBaseSpec() map[string]any {
	serverURL := sm.getServerURL()

	// üö® DEBUG : Log pour v√©rifier l'URL g√©n√©r√©e
	log.Printf("üîç Swagger server URL configured: %s", serverURL)

	return map[string]any{
		"openapi": "3.0.3",
		"info": map[string]any{
			"title":       "OCF API Documentation",
			"version":     sm.getAPIVersion(),
			"description": "API compl√®te pour OCF - Documentation hybride (manuelle + auto-g√©n√©r√©e)",
			"contact": map[string]any{
				"name": "OCF Development Team",
			},
			"x-documentation-type": "hybrid",
			"x-generated-at":       sm.getCurrentTimestamp(),
		},
		"servers": []map[string]any{
			{
				"url":         serverURL,
				"description": "OCF API Server",
			},
		},
		"paths": make(map[string]any),
		"components": map[string]any{
			"schemas": make(map[string]any),
			"securitySchemes": map[string]any{
				"Bearer": map[string]any{
					"type":         "http",
					"scheme":       "bearer",
					"bearerFormat": "JWT",
					"description":  "JWT token for authentication",
				},
			},
		},
		"tags": []map[string]any{},
	}
}

func (sm *SwaggerSpecMerger) getSwagSpecSafely() map[string]any {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("‚ö†Ô∏è  Failed to get swag spec (panic): %v", r)
		}
	}()

	// Debug: V√©rifier si docs.SwaggerInfo existe
	if docs.SwaggerInfo == nil {
		log.Println("‚ö†Ô∏è  docs.SwaggerInfo is nil - swag might not be initialized")
		return nil
	}

	log.Printf("üìã SwaggerInfo available - Title: '%s', Version: '%s', Host: '%s'",
		docs.SwaggerInfo.Title, docs.SwaggerInfo.Version, docs.SwaggerInfo.Host)

	// Essayer de r√©cup√©rer la spec swag
	swagJSON := docs.SwaggerInfo.ReadDoc()
	if swagJSON == "" {
		log.Println("‚ö†Ô∏è  No swag documentation available")
		return nil
	}

	log.Printf("üìÑ Raw swag JSON loaded successfully (%d characters)", len(swagJSON))

	var swagSpec map[string]any
	if err := json.Unmarshal([]byte(swagJSON), &swagSpec); err != nil {
		log.Printf("‚ö†Ô∏è  Failed to unmarshal swag spec: %v", err)
		return nil
	}

	return swagSpec
}

func (sm *SwaggerSpecMerger) addSwagContent(baseSpec map[string]any) {
	swagSpec := sm.getSwagSpecSafely()
	if swagSpec == nil {
		log.Println("‚ö†Ô∏è  No swag documentation found, using auto-generated only")
		return
	}

	log.Printf("üìö Processing swag content...")

	// NOUVEAU: Convertir Swagger 2.0 vers OpenAPI 3.0 AVANT tout traitement
	sm.convertSwagger2ToOpenAPI3(swagSpec)

	// Convertir les body params en requestBody AVANT le merge
	sm.convertBodyParamsToRequestBody(swagSpec)
	log.Printf("üìö Converted Swagger 2.0 body params to OpenAPI 3.0 requestBody")

	// Merger les paths de swag
	if swagPaths := sm.getPaths(swagSpec); swagPaths != nil {
		basePaths := sm.getPaths(baseSpec)
		addedPaths := 0
		for path, pathSpec := range swagPaths {
			// Pr√©fixer pour √©viter les conflits avec l'auto-g√©n√©r√©
			if !sm.isAutoGeneratedPath(path) {
				basePaths[path] = pathSpec
				addedPaths++
				log.Printf("  üìö Added swag path: %s", path)
			} else {
				log.Printf("  ‚è≠Ô∏è  Skipped swag path (auto-generated exists): %s", path)
			}
		}
		log.Printf("üìö Added %d swag paths", addedPaths)
	}

	// Merger les tags de swag
	if swagTags := sm.getTags(swagSpec); swagTags != nil {
		if swagTagsList, ok := swagTags.([]any); ok {
			baseTags := baseSpec["tags"].([]map[string]any)
			for _, tag := range swagTagsList {
				if tagMap, ok := tag.(map[string]any); ok {
					baseTags = append(baseTags, tagMap)
				}
			}
			baseSpec["tags"] = baseTags
		}
	}

	// Merger les sch√©mas de swag si disponibles
	if swagComponents := sm.getComponents(swagSpec); swagComponents != nil {
		if swagSchemas, exists := swagComponents["schemas"]; exists {
			baseComponents := baseSpec["components"].(map[string]any)
			baseSchemas := baseComponents["schemas"].(map[string]any)

			if swagSchemasMap, ok := swagSchemas.(map[string]any); ok {
				for schemaName, schema := range swagSchemasMap {
					baseSchemas[schemaName] = schema
					log.Printf("  üìù Added swag schema: %s", schemaName)
				}
				log.Printf("üìö Successfully merged %d swag schemas", len(swagSchemasMap))
			}
		}
	}

	log.Printf("üìö Merged swag documentation with body parameter conversion")
}

// R√©cup√©rer les sch√©mas depuis components
func (sm *SwaggerSpecMerger) getSchemas(spec map[string]any) map[string]any {
	if components := sm.getComponents(spec); components != nil {
		if schemas, exists := components["schemas"]; exists {
			if schemasMap, ok := schemas.(map[string]any); ok {
				return schemasMap
			}
		}
	}
	return make(map[string]any)
}

func (sm *SwaggerSpecMerger) convertSwagger2References(spec map[string]any) {
	// Convertir r√©cursivement toutes les r√©f√©rences dans la spec
	sm.convertReferencesInMap(spec)
}

func (sm *SwaggerSpecMerger) convertReferencesInMap(obj any) {
	switch v := obj.(type) {
	case map[string]any:
		for key, value := range v {
			if key == "$ref" {
				if refStr, ok := value.(string); ok {
					// Convertir #/definitions/X vers #/components/schemas/X
					if strings.HasPrefix(refStr, "#/definitions/") {
						newRef := strings.Replace(refStr, "#/definitions/", "#/components/schemas/", 1)
						v[key] = newRef
						log.Printf("üîÑ Converted reference: %s -> %s", refStr, newRef)
					}
				}
			} else {
				sm.convertReferencesInMap(value)
			}
		}
	case []any:
		for _, item := range v {
			sm.convertReferencesInMap(item)
		}
	}
}

// Ajouter les sch√©mas communs manquants
func (sm *SwaggerSpecMerger) addCommonSchemas(spec map[string]any) {
	schemas := sm.getSchemas(spec)

	// Utiliser le service de sch√©mas additionnels
	additionalSchemasService := NewAdditionalSchemasService()
	additionalSchemas := additionalSchemasService.GetAllSchemas()
	for schemaName, schema := range additionalSchemas {
		if _, exists := schemas[schemaName]; !exists {
			schemas[schemaName] = schema
			log.Printf("üîß Added schema: %s", schemaName)
		}
	}

	log.Printf("üîß Added %d additional schemas", len(additionalSchemas))
}

// addAutoGeneratedContent ajoute la documentation auto-g√©n√©r√©e
func (sm *SwaggerSpecMerger) addAutoGeneratedContent(baseSpec, autoSpec map[string]any) {
	log.Println("ü§ñ Generating auto-documentation for entities...")

	if autoSpec == nil {
		log.Println("‚ö†Ô∏è  No auto-generated documentation available")
		return
	}

	autoPathsCount := len(sm.getPaths(autoSpec))
	log.Printf("ü§ñ Generated auto-documentation with %d paths", autoPathsCount)

	// Merger les paths auto-g√©n√©r√©s
	if autoPaths := sm.getPaths(autoSpec); autoPaths != nil {
		basePaths := sm.getPaths(baseSpec)
		addedCount := 0
		skippedCount := 0

		for path, pathSpec := range autoPaths {
			if _, exists := basePaths[path]; !exists {
				// Aucun conflit : ajouter le path auto-g√©n√©r√©
				sm.markAsAutoGenerated(pathSpec)
				basePaths[path] = pathSpec
				addedCount++
				log.Printf("  ü§ñ Added auto-generated path: %s", path)
			} else {
				skippedCount++
				log.Printf("  ‚è≠Ô∏è  Skipped auto-generated path (manual exists): %s", path)
			}
		}

		log.Printf("ü§ñ Auto-generated paths: %d added, %d skipped (conflicts)", addedCount, skippedCount)
	}

	// Merger les tags auto-g√©n√©r√©s
	if autoTags := sm.getTags(autoSpec); autoTags != nil {
		if autoTagsList, ok := autoTags.([]any); ok {
			baseTags := baseSpec["tags"].([]map[string]any)

			for _, autoTag := range autoTagsList {
				if autoTagMap, ok := autoTag.(map[string]any); ok {
					// V√©rifier si le tag existe d√©j√†
					exists := false
					for _, existingTag := range baseTags {
						if existingTag["name"] == autoTagMap["name"] {
							exists = true
							break
						}
					}

					if !exists {
						autoTagMap["x-auto-generated"] = true
						baseTags = append(baseTags, autoTagMap)
					}
				}
			}
			baseSpec["tags"] = baseTags
		}
	}

	// Merger les sch√©mas auto-g√©n√©r√©s
	if autoComponents := sm.getComponents(autoSpec); autoComponents != nil {
		if autoSchemas, exists := autoComponents["schemas"]; exists {
			baseComponents := baseSpec["components"].(map[string]any)
			baseSchemas := baseComponents["schemas"].(map[string]any)

			if autoSchemasMap, ok := autoSchemas.(map[string]any); ok {
				addedSchemasCount := 0
				skippedSchemasCount := 0

				for schemaName, schema := range autoSchemasMap {
					if _, exists := baseSchemas[schemaName]; !exists {
						if schemaMap, ok := schema.(map[string]any); ok {
							schemaMap["x-auto-generated"] = true
							baseSchemas[schemaName] = schemaMap
							addedSchemasCount++
							log.Printf("  üß© Added auto-generated schema: %s", schemaName)
						}
					} else {
						skippedSchemasCount++
						log.Printf("  ‚è≠Ô∏è  Skipped auto-generated schema (manual exists): %s", schemaName)
					}
				}

				log.Printf("ü§ñ Auto-generated schemas: %d added, %d skipped", addedSchemasCount, skippedSchemasCount)
			}
		}
	}

	entityCount := len(ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs())
	log.Printf("‚úÖ Auto-generated documentation processed for %d entities", entityCount)
}

// validateAndFixSpec valide et corrige la spec finale
func (sm *SwaggerSpecMerger) validateAndFixSpec(spec map[string]any) {
	// S'assurer que les champs obligatoires existent
	if _, exists := spec["openapi"]; !exists {
		spec["openapi"] = "3.0.3"
		log.Println("üîß Added missing openapi version field")
	}

	if info, exists := spec["info"]; exists {
		if infoMap, ok := info.(map[string]any); ok {
			if _, exists := infoMap["title"]; !exists {
				infoMap["title"] = "OCF API"
				log.Println("üîß Added missing title field")
			}
			if _, exists := infoMap["version"]; !exists {
				infoMap["version"] = "1.0.0"
				log.Println("üîß Added missing version field")
			}
		}
	}

	// S'assurer que paths existe
	if _, exists := spec["paths"]; !exists {
		spec["paths"] = make(map[string]any)
		log.Println("üîß Added missing paths field")
	}

	// URL du serveur
	if servers, exists := spec["servers"]; exists {
		if serversList, ok := servers.([]map[string]any); ok {
			for _, server := range serversList {
				if url, exists := server["url"]; exists {
					if urlStr, ok := url.(string); ok {
						// Corriger localhost:// vers http://localhost:
						if strings.Contains(urlStr, "localhost://") {
							server["url"] = strings.Replace(urlStr, "localhost://", "http://localhost:", 1)
							log.Printf("üîß Fixed server URL: %s", server["url"])
						}
					}
				}
			}
		}
	}

	// Ajouter des m√©tadonn√©es sur le processus de merge
	if info, exists := spec["info"]; exists {
		if infoMap, ok := info.(map[string]any); ok {
			infoMap["x-merge-info"] = map[string]any{
				"auto-generated-entities": len(ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs()),
				"manual-paths":            sm.countManualPaths(spec),
				"auto-paths":              sm.countAutoPaths(spec),
				"total-schemas":           len(sm.getSchemas(spec)),
				"generated-at":            sm.getCurrentTimestamp(),
			}
		}
	}
}

// Fonctions utilitaires

func (sm *SwaggerSpecMerger) isAutoGeneratedPath(path string) bool {
	// Les paths auto-g√©n√©r√©s suivent le pattern /entityname ou /entityname/{id}
	autoGeneratedPrefixes := []string{
		"/subscriptionplans",
	}

	for _, prefix := range autoGeneratedPrefixes {
		if path == prefix || path == prefix+"/{id}" {
			return true
		}
	}
	return false
}

func (sm *SwaggerSpecMerger) markAsAutoGenerated(pathSpec any) {
	if pathMap, ok := pathSpec.(map[string]any); ok {
		for _, methodSpec := range pathMap {
			if methodMap, ok := methodSpec.(map[string]any); ok {
				if tags, exists := methodMap["tags"]; exists {
					if tagsList, ok := tags.([]any); ok {
						// Convertir en []string et ajouter le tag auto-generated
						stringTags := make([]string, 0, len(tagsList)+1)
						for _, tag := range tagsList {
							if tagStr, ok := tag.(string); ok {
								stringTags = append(stringTags, tagStr)
							}
						}
						stringTags = append(stringTags, "auto-generated")
						methodMap["tags"] = stringTags
					}
				} else {
					methodMap["tags"] = []string{"auto-generated"}
				}
				methodMap["x-auto-generated"] = true
			}
		}
	}
}

func (sm *SwaggerSpecMerger) countManualPaths(spec map[string]any) int {
	count := 0
	if paths := sm.getPaths(spec); paths != nil {
		for _, pathSpec := range paths {
			if !sm.hasAutoGeneratedMarker(pathSpec) {
				count++
			}
		}
	}
	return count
}

func (sm *SwaggerSpecMerger) countAutoPaths(spec map[string]any) int {
	count := 0
	if paths := sm.getPaths(spec); paths != nil {
		for _, pathSpec := range paths {
			if sm.hasAutoGeneratedMarker(pathSpec) {
				count++
			}
		}
	}
	return count
}

func (sm *SwaggerSpecMerger) hasAutoGeneratedMarker(pathSpec any) bool {
	if pathMap, ok := pathSpec.(map[string]any); ok {
		for _, methodSpec := range pathMap {
			if methodMap, ok := methodSpec.(map[string]any); ok {
				if autoGen, exists := methodMap["x-auto-generated"]; exists {
					if autoGenBool, ok := autoGen.(bool); ok && autoGenBool {
						return true
					}
				}
			}
		}
	}
	return false
}

func (sm *SwaggerSpecMerger) getAPIVersion() string {
	if version := os.Getenv("OCF_VERSION"); version != "" {
		return version
	}
	return "1.0.0"
}

func (sm *SwaggerSpecMerger) getServerURL() string {
	if url := os.Getenv("OCF_API_URL"); url != "" {
		return docs.SwaggerInfo.Schemes[0] + "://" + url + "/api/v1"
	}
	return "/api/v1"
}

func (sm *SwaggerSpecMerger) getCurrentTimestamp() string {
	return fmt.Sprintf("%d", time.Now().Unix())
}

// Fonctions utilitaires h√©rit√©es
func (sm *SwaggerSpecMerger) getPaths(spec map[string]any) map[string]any {
	if paths, exists := spec["paths"]; exists {
		if pathsMap, ok := paths.(map[string]any); ok {
			return pathsMap
		}
	}
	return make(map[string]any)
}

func (sm *SwaggerSpecMerger) getComponents(spec map[string]any) map[string]any {
	if components, exists := spec["components"]; exists {
		if componentsMap, ok := components.(map[string]any); ok {
			return componentsMap
		}
	}
	return nil
}

func (sm *SwaggerSpecMerger) getTags(spec map[string]any) any {
	if tags, exists := spec["tags"]; exists {
		return tags
	}
	return nil
}

// SwaggerMergeMiddleware permet d'exposer la spec merg√©e
func SwaggerMergeMiddleware() func() map[string]any {
	merger := NewSwaggerSpecMerger()

	return func() map[string]any {
		return merger.MergeSpecs()
	}
}

// convertBodyParamsToRequestBody convertit les param√®tres body Swagger 2.0 en requestBody OpenAPI 3.0
func (sm *SwaggerSpecMerger) convertBodyParamsToRequestBody(spec map[string]any) {
	paths := sm.getPaths(spec)
	if paths == nil {
		return
	}

	log.Println("üîÑ Converting Swagger 2.0 body parameters to OpenAPI 3.0 requestBody...")

	for pathKey, pathValue := range paths {
		if pathMap, ok := pathValue.(map[string]any); ok {
			// Pour chaque m√©thode HTTP (get, post, put, patch, delete)
			for method, methodValue := range pathMap {
				if methodMap, ok := methodValue.(map[string]any); ok {
					converted := sm.convertMethodBodyParams(methodMap)
					if converted {
						log.Printf("  ‚úÖ Converted %s %s", method, pathKey)
					}
				}
			}
		}
	}
}

// convertMethodBodyParams convertit les body params d'une m√©thode sp√©cifique
func (sm *SwaggerSpecMerger) convertMethodBodyParams(methodMap map[string]any) bool {
	parameters, hasParams := methodMap["parameters"]
	if !hasParams {
		return false
	}

	paramList, ok := parameters.([]any)
	if !ok {
		return false
	}

	var bodyParam map[string]any
	otherParams := make([]any, 0, len(paramList))
	var foundBodyParam = false

	// S√©parer les param√®tres body des autres
	for _, param := range paramList {
		if paramMap, ok := param.(map[string]any); ok {
			if in, exists := paramMap["in"]; exists && in == "body" {
				bodyParam = paramMap
				foundBodyParam = true
			} else {
				otherParams = append(otherParams, param)
			}
		}
	}

	// Si on a trouv√© un param√®tre body, le convertir en requestBody
	if foundBodyParam && bodyParam != nil {
		// Cr√©er le requestBody OpenAPI 3.0
		requestBody := map[string]any{
			"required": true,
			"content": map[string]any{
				"application/json": map[string]any{},
			},
		}

		// Ajouter le schema
		if schema, exists := bodyParam["schema"]; exists {
			content := requestBody["content"].(map[string]any)
			applicationJson := content["application/json"].(map[string]any)
			applicationJson["schema"] = schema
		}

		// Ajouter la description si elle existe
		if description, exists := bodyParam["description"]; exists {
			requestBody["description"] = description
		}

		// Ajouter required depuis le param√®tre si sp√©cifi√©
		if required, exists := bodyParam["required"]; exists {
			requestBody["required"] = required
		}

		// Mettre √† jour la m√©thode
		methodMap["requestBody"] = requestBody

		// Mettre √† jour les param√®tres (sans le body param)
		if len(otherParams) > 0 {
			methodMap["parameters"] = otherParams
		} else {
			delete(methodMap, "parameters")
		}

		return true
	}

	return false
}

func (sm *SwaggerSpecMerger) diagnoseAndFixSchemaIssues(baseSpec map[string]any) {
	schemas := sm.getSchemas(baseSpec)

	log.Printf("üîç Current schemas in baseSpec: %d", len(schemas))
	for name := range schemas {
		log.Printf("  üìã Schema available: %s", name)
	}

	// Analyser la spec swag pour comprendre le probl√®me
	swagSpec := sm.getSwagSpecSafely()
	if swagSpec != nil {
		if swagComponents := sm.getComponents(swagSpec); swagComponents != nil {
			if swagSchemas, exists := swagComponents["schemas"]; exists {
				if swagSchemasMap, ok := swagSchemas.(map[string]any); ok {
					log.Printf("üìã Swag schemas found: %d", len(swagSchemasMap))
					for name := range swagSchemasMap {
						log.Printf("  üìù Swag schema: %s", name)
						// Ajouter les sch√©mas swag manquants
						if _, exists := schemas[name]; !exists {
							schemas[name] = swagSchemasMap[name]
							log.Printf("  ‚úÖ Added missing swag schema: %s", name)
						}
					}
				}
			}
		}
	} else {
		log.Printf("‚ö†Ô∏è Swag spec not available")
		//sm.addFallbackDtoSchemas(baseSpec)
	}
}

// convertSwagger2ToOpenAPI3 convertit les definitions en schemas
func (sm *SwaggerSpecMerger) convertSwagger2ToOpenAPI3(spec map[string]any) {
	log.Printf("üîÑ Converting Swagger 2.0 definitions to OpenAPI 3.0 schemas...")

	// V√©rifier s'il y a des definitions √† convertir
	if definitions, exists := spec["definitions"]; exists {
		if defsMap, ok := definitions.(map[string]any); ok {
			log.Printf("üîÑ Converting %d definitions to schemas", len(defsMap))

			// S'assurer que components existe
			if _, exists := spec["components"]; !exists {
				spec["components"] = make(map[string]any)
			}

			components := spec["components"].(map[string]any)

			// S'assurer que schemas existe
			if _, exists := components["schemas"]; !exists {
				components["schemas"] = make(map[string]any)
			}

			schemas := components["schemas"].(map[string]any)

			// Copier toutes les definitions vers schemas
			for name, def := range defsMap {
				schemas[name] = def
				log.Printf("  ‚úÖ Converted definition: %s", name)
			}

			// Optionnel: supprimer les definitions apr√®s conversion
			delete(spec, "definitions")
			log.Printf("üîÑ Conversion complete: %d schemas now available", len(schemas))
		}
	}
}
