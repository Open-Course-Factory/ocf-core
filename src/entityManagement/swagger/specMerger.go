// src/entityManagement/swagger/specMerger.go
package swagger

import (
	"encoding/json"
	"fmt"
	"log"
	"os"

	"soli/formations/docs" // G√©n√©r√© par swag init
	ems "soli/formations/src/entityManagement/entityManagementService"
)

// SwaggerSpecMerger combine la documentation swag avec la documentation auto-g√©n√©r√©e
type SwaggerSpecMerger struct {
	docGenerator *DocumentationGenerator
}

func NewSwaggerSpecMerger() *SwaggerSpecMerger {
	return &SwaggerSpecMerger{
		docGenerator: NewDocumentationGenerator(),
	}
}

// MergeSpecs combine les deux sources de documentation
func (sm *SwaggerSpecMerger) MergeSpecs() map[string]interface{} {
	// 1. R√©cup√©rer la spec swag g√©n√©r√©e
	baseSpec := sm.createValidBaseSpec()

	// 2. R√©cup√©rer et ajouter la spec swag si disponible
	sm.addSwagContent(baseSpec)

	// 3. Ajouter la documentation auto-g√©n√©r√©e
	sm.addAutoGeneratedContent(baseSpec)

	// 4. Valider la spec finale
	sm.validateAndFixSpec(baseSpec)

	log.Printf("‚úÖ Generated valid OpenAPI spec with %d paths",
		len(sm.getPaths(baseSpec)))

	return baseSpec
}

// createValidBaseSpec cr√©e une sp√©cification OpenAPI de base valide
func (sm *SwaggerSpecMerger) createValidBaseSpec() map[string]interface{} {
	return map[string]interface{}{
		"openapi": "3.0.3", // ‚úÖ Version OpenAPI valide
		"info": map[string]interface{}{
			"title":       "OCF API Documentation",
			"version":     sm.getAPIVersion(),
			"description": "API compl√®te pour OCF - Documentation hybride (manuelle + auto-g√©n√©r√©e)",
			"contact": map[string]interface{}{
				"name": "OCF Development Team",
			},
			"x-documentation-type": "hybrid",
			"x-generated-at":       sm.getCurrentTimestamp(),
		},
		"servers": []map[string]interface{}{
			{
				"url":         sm.getServerURL(),
				"description": "OCF API Server",
			},
		},
		"paths": make(map[string]interface{}),
		"components": map[string]interface{}{
			"schemas": make(map[string]interface{}),
			"securitySchemes": map[string]interface{}{
				"Bearer": map[string]interface{}{
					"type":         "http",
					"scheme":       "bearer",
					"bearerFormat": "JWT",
					"description":  "JWT token for authentication",
				},
			},
		},
		"tags": []map[string]interface{}{},
	}
}

// addSwagContent ajoute le contenu de la documentation swag
func (sm *SwaggerSpecMerger) addSwagContent(baseSpec map[string]interface{}) {
	swagSpec := sm.getSwagSpecSafely()
	if swagSpec == nil {
		log.Println("‚ö†Ô∏è  No swag documentation found, using auto-generated only")
		return
	}

	// Merger les paths de swag
	if swagPaths := sm.getPaths(swagSpec); swagPaths != nil {
		basePaths := sm.getPaths(baseSpec)
		for path, pathSpec := range swagPaths {
			// Pr√©fixer pour √©viter les conflits avec l'auto-g√©n√©r√©
			if !sm.isAutoGeneratedPath(path) {
				basePaths[path] = pathSpec
			}
		}
	}

	// Merger les tags de swag
	if swagTags := sm.getTags(swagSpec); swagTags != nil {
		if swagTagsList, ok := swagTags.([]interface{}); ok {
			baseTags := baseSpec["tags"].([]map[string]interface{})
			for _, tag := range swagTagsList {
				if tagMap, ok := tag.(map[string]interface{}); ok {
					baseTags = append(baseTags, tagMap)
				}
			}
			baseSpec["tags"] = baseTags
		}
	}

	// Merger les sch√©mas de swag si disponibles
	if swagComponents := sm.getComponents(swagSpec); swagComponents != nil {
		if swagSchemas, exists := swagComponents["schemas"]; exists {
			baseComponents := baseSpec["components"].(map[string]interface{})
			baseSchemas := baseComponents["schemas"].(map[string]interface{})

			if swagSchemasMap, ok := swagSchemas.(map[string]interface{}); ok {
				for schemaName, schema := range swagSchemasMap {
					baseSchemas[schemaName] = schema
				}
			}
		}
	}

	log.Printf("üìö Merged swag documentation")
}

// addAutoGeneratedContent ajoute la documentation auto-g√©n√©r√©e
func (sm *SwaggerSpecMerger) addAutoGeneratedContent(baseSpec map[string]interface{}) {
	autoSpec := sm.docGenerator.GenerateOpenAPISpec()

	if autoSpec == nil {
		log.Println("‚ö†Ô∏è  No auto-generated documentation available")
		return
	}

	// Merger les paths auto-g√©n√©r√©s
	if autoPaths := sm.getPaths(autoSpec); autoPaths != nil {
		basePaths := sm.getPaths(baseSpec)
		for path, pathSpec := range autoPaths {
			if _, exists := basePaths[path]; !exists {
				// Marquer comme auto-g√©n√©r√©
				sm.markAsAutoGenerated(pathSpec)
				basePaths[path] = pathSpec
			}
		}
	}

	// Merger les tags auto-g√©n√©r√©s
	if autoTags := sm.getTags(autoSpec); autoTags != nil {
		if autoTagsList, ok := autoTags.([]interface{}); ok {
			baseTags := baseSpec["tags"].([]map[string]interface{})

			for _, autoTag := range autoTagsList {
				if autoTagMap, ok := autoTag.(map[string]interface{}); ok {
					// V√©rifier si le tag existe d√©j√†
					exists := false
					for _, existingTag := range baseTags {
						if existingTag["name"] == autoTagMap["name"] {
							exists = true
							break
						}
					}

					if !exists {
						autoTagMap["x-auto-generated"] = true
						baseTags = append(baseTags, autoTagMap)
					}
				}
			}
			baseSpec["tags"] = baseTags
		}
	}

	// Merger les sch√©mas auto-g√©n√©r√©s
	if autoComponents := sm.getComponents(autoSpec); autoComponents != nil {
		if autoSchemas, exists := autoComponents["schemas"]; exists {
			baseComponents := baseSpec["components"].(map[string]interface{})
			baseSchemas := baseComponents["schemas"].(map[string]interface{})

			if autoSchemasMap, ok := autoSchemas.(map[string]interface{}); ok {
				for schemaName, schema := range autoSchemasMap {
					if _, exists := baseSchemas[schemaName]; !exists {
						if schemaMap, ok := schema.(map[string]interface{}); ok {
							schemaMap["x-auto-generated"] = true
							baseSchemas[schemaName] = schemaMap
						}
					}
				}
			}
		}
	}

	entityCount := len(ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs())
	log.Printf("ü§ñ Added auto-generated documentation for %d entities", entityCount)
}

// validateAndFixSpec valide et corrige la spec finale
func (sm *SwaggerSpecMerger) validateAndFixSpec(spec map[string]interface{}) {
	// S'assurer que les champs obligatoires existent
	if _, exists := spec["openapi"]; !exists {
		spec["openapi"] = "3.0.3"
		log.Println("üîß Added missing openapi version field")
	}

	if info, exists := spec["info"]; exists {
		if infoMap, ok := info.(map[string]interface{}); ok {
			if _, exists := infoMap["title"]; !exists {
				infoMap["title"] = "OCF API"
				log.Println("üîß Added missing title field")
			}
			if _, exists := infoMap["version"]; !exists {
				infoMap["version"] = "1.0.0"
				log.Println("üîß Added missing version field")
			}
		}
	}

	// S'assurer que paths existe
	if _, exists := spec["paths"]; !exists {
		spec["paths"] = make(map[string]interface{})
		log.Println("üîß Added missing paths field")
	}

	// Ajouter des m√©tadonn√©es sur le processus de merge
	if info, exists := spec["info"]; exists {
		if infoMap, ok := info.(map[string]interface{}); ok {
			infoMap["x-merge-info"] = map[string]interface{}{
				"auto-generated-entities": len(ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs()),
				"manual-paths":            sm.countManualPaths(spec),
				"auto-paths":              sm.countAutoPaths(spec),
				"generated-at":            sm.getCurrentTimestamp(),
			}
		}
	}
}

// Fonctions utilitaires

func (sm *SwaggerSpecMerger) getSwagSpecSafely() map[string]interface{} {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("‚ö†Ô∏è  Failed to get swag spec: %v", r)
		}
	}()

	// Essayer de r√©cup√©rer la spec swag
	if docs.SwaggerInfo.ReadDoc() == "" {
		log.Println("‚ö†Ô∏è  SwaggerInfo.ReadDoc is nil")
		return nil
	}

	swagJSON := docs.SwaggerInfo.ReadDoc()
	if swagJSON == "" {
		log.Println("‚ö†Ô∏è  Empty swag documentation")
		return nil
	}

	var swagSpec map[string]interface{}
	if err := json.Unmarshal([]byte(swagJSON), &swagSpec); err != nil {
		log.Printf("‚ö†Ô∏è  Failed to unmarshal swag spec: %v", err)
		return nil
	}

	return swagSpec
}

func (sm *SwaggerSpecMerger) isAutoGeneratedPath(path string) bool {
	// Les paths auto-g√©n√©r√©s suivent le pattern /entityname ou /entityname/{id}
	// Vous pouvez ajuster cette logique selon vos besoins
	autoGeneratedPrefixes := []string{
		"/subscriptionplans", "/usersubscriptions", "/paymentmethods",
		"/invoices", "/billingaddresses", "/usagemetrics",
	}

	for _, prefix := range autoGeneratedPrefixes {
		if path == prefix || path == prefix+"/{id}" {
			return true
		}
	}
	return false
}

func (sm *SwaggerSpecMerger) markAsAutoGenerated(pathSpec interface{}) {
	if pathMap, ok := pathSpec.(map[string]interface{}); ok {
		for _, methodSpec := range pathMap {
			if methodMap, ok := methodSpec.(map[string]interface{}); ok {
				if tags, exists := methodMap["tags"]; exists {
					if tagsList, ok := tags.([]interface{}); ok {
						// Convertir en []string et ajouter le tag auto-generated
						var stringTags []string
						for _, tag := range tagsList {
							if tagStr, ok := tag.(string); ok {
								stringTags = append(stringTags, tagStr)
							}
						}
						stringTags = append(stringTags, "auto-generated")
						methodMap["tags"] = stringTags
					}
				} else {
					methodMap["tags"] = []string{"auto-generated"}
				}
				methodMap["x-auto-generated"] = true
			}
		}
	}
}

func (sm *SwaggerSpecMerger) countManualPaths(spec map[string]interface{}) int {
	count := 0
	if paths := sm.getPaths(spec); paths != nil {
		for _, pathSpec := range paths {
			if !sm.hasAutoGeneratedMarker(pathSpec) {
				count++
			}
		}
	}
	return count
}

func (sm *SwaggerSpecMerger) countAutoPaths(spec map[string]interface{}) int {
	count := 0
	if paths := sm.getPaths(spec); paths != nil {
		for _, pathSpec := range paths {
			if sm.hasAutoGeneratedMarker(pathSpec) {
				count++
			}
		}
	}
	return count
}

func (sm *SwaggerSpecMerger) hasAutoGeneratedMarker(pathSpec interface{}) bool {
	if pathMap, ok := pathSpec.(map[string]interface{}); ok {
		for _, methodSpec := range pathMap {
			if methodMap, ok := methodSpec.(map[string]interface{}); ok {
				if autoGen, exists := methodMap["x-auto-generated"]; exists {
					if autoGenBool, ok := autoGen.(bool); ok && autoGenBool {
						return true
					}
				}
			}
		}
	}
	return false
}

func (sm *SwaggerSpecMerger) getAPIVersion() string {
	if version := os.Getenv("OCF_VERSION"); version != "" {
		return version
	}
	return "1.0.0"
}

func (sm *SwaggerSpecMerger) getServerURL() string {
	if url := os.Getenv("OCF_API_URL"); url != "" {
		return url + "/api/v1"
	}
	return "/api/v1"
}

func (sm *SwaggerSpecMerger) getCurrentTimestamp() string {
	return fmt.Sprintf("%d", sm.getCurrentUnixTime())
}

func (sm *SwaggerSpecMerger) getCurrentUnixTime() int64 {
	// Fonction pour obtenir le timestamp actuel
	// Vous pouvez utiliser time.Now().Unix()
	return 1699900000 // Placeholder
}

// Fonctions utilitaires h√©rit√©es (identiques au code pr√©c√©dent)
func (sm *SwaggerSpecMerger) getPaths(spec map[string]interface{}) map[string]interface{} {
	if paths, exists := spec["paths"]; exists {
		if pathsMap, ok := paths.(map[string]interface{}); ok {
			return pathsMap
		}
	}
	return nil
}

func (sm *SwaggerSpecMerger) getComponents(spec map[string]interface{}) map[string]interface{} {
	if components, exists := spec["components"]; exists {
		if componentsMap, ok := components.(map[string]interface{}); ok {
			return componentsMap
		}
	}
	return nil
}

// getSwagSpec r√©cup√®re la spec g√©n√©r√©e par swag init
func (sm *SwaggerSpecMerger) getSwagSpec() map[string]interface{} {
	// Convertir docs.SwaggerInfo en map
	swagJSON, err := json.Marshal(docs.SwaggerInfo)
	if err != nil {
		log.Printf("‚ö†Ô∏è  Failed to marshal swag spec: %v", err)
		return make(map[string]interface{})
	}

	var swagSpec map[string]interface{}
	if err := json.Unmarshal(swagJSON, &swagSpec); err != nil {
		log.Printf("‚ö†Ô∏è  Failed to unmarshal swag spec: %v", err)
		return make(map[string]interface{})
	}

	return swagSpec
}

// mergeTwoSpecs combine deux specs OpenAPI
func (sm *SwaggerSpecMerger) mergeTwoSpecs(swagSpec, autoSpec map[string]interface{}) map[string]interface{} {
	// Commencer avec la spec swag comme base
	mergedSpec := sm.deepCopy(swagSpec)

	// Merger les paths
	sm.mergePaths(mergedSpec, autoSpec)

	// Merger les components/schemas
	sm.mergeSchemas(mergedSpec, autoSpec)

	// Merger les tags
	sm.mergeTags(mergedSpec, autoSpec)

	// Ajouter des m√©tadonn√©es sur le merge
	sm.addMergeMetadata(mergedSpec)

	return mergedSpec
}

// mergePaths combine les paths des deux specs
func (sm *SwaggerSpecMerger) mergePaths(mergedSpec, autoSpec map[string]interface{}) {
	swagPaths := sm.getPaths(mergedSpec)
	autoPaths := sm.getPaths(autoSpec)

	// Cr√©er le map paths s'il n'existe pas
	if swagPaths == nil {
		mergedSpec["paths"] = make(map[string]interface{})
		swagPaths = sm.getPaths(mergedSpec)
	}

	// Ajouter les paths auto-g√©n√©r√©s
	for path, pathSpec := range autoPaths {
		if existingPath, exists := swagPaths[path]; exists {
			// Le path existe d√©j√†, merger les m√©thodes HTTP
			sm.mergePathMethods(existingPath.(map[string]interface{}), pathSpec.(map[string]interface{}))
		} else {
			// Nouveau path, l'ajouter directement
			swagPaths[path] = pathSpec
		}
	}
}

// mergePathMethods combine les m√©thodes HTTP d'un m√™me path
func (sm *SwaggerSpecMerger) mergePathMethods(existing, newPath map[string]interface{}) {
	for method, methodSpec := range newPath {
		if _, exists := existing[method]; !exists {
			// Ajouter la m√©thode avec un tag pour indiquer qu'elle est auto-g√©n√©r√©e
			if methodMap, ok := methodSpec.(map[string]interface{}); ok {
				// Ajouter un tag sp√©cial pour les routes auto-g√©n√©r√©es
				if tags, exists := methodMap["tags"]; exists {
					if tagsList, ok := tags.([]string); ok {
						methodMap["tags"] = append(tagsList, "auto-generated")
					}
				} else {
					methodMap["tags"] = []string{"auto-generated"}
				}
				existing[method] = methodMap
			}
		}
		// Si la m√©thode existe d√©j√†, on garde celle de swag (priorit√© au manuel)
	}
}

// mergeSchemas combine les sch√©mas des deux specs
func (sm *SwaggerSpecMerger) mergeSchemas(mergedSpec, autoSpec map[string]interface{}) {
	// R√©cup√©rer les components existants
	components := sm.getOrCreateComponents(mergedSpec)
	autoComponents := sm.getComponents(autoSpec)

	if autoComponents != nil {
		if autoSchemas, exists := autoComponents["schemas"]; exists {
			schemas := sm.getOrCreateSchemas(components)

			// Ajouter les sch√©mas auto-g√©n√©r√©s
			if autoSchemasMap, ok := autoSchemas.(map[string]interface{}); ok {
				for schemaName, schema := range autoSchemasMap {
					// Pr√©fixer les sch√©mas auto-g√©n√©r√©s pour √©viter les conflits
					autoSchemaName := fmt.Sprintf("AutoGenerated%s", schemaName)
					if _, exists := schemas[autoSchemaName]; !exists {
						schemas[autoSchemaName] = schema
					}
				}
			}
		}
	}
}

// mergeTags combine les tags des deux specs
func (sm *SwaggerSpecMerger) mergeTags(mergedSpec, autoSpec map[string]interface{}) {
	swagTags := sm.getTags(mergedSpec)
	autoTags := sm.getTags(autoSpec)

	if autoTags != nil && swagTags != nil {
		// Convertir en maps pour faciliter la fusion
		existingTagNames := make(map[string]bool)
		if swagTagsList, ok := swagTags.([]interface{}); ok {
			for _, tag := range swagTagsList {
				if tagMap, ok := tag.(map[string]interface{}); ok {
					if name, exists := tagMap["name"]; exists {
						existingTagNames[name.(string)] = true
					}
				}
			}

			// Ajouter les nouveaux tags
			if autoTagsList, ok := autoTags.([]interface{}); ok {
				for _, autoTag := range autoTagsList {
					if autoTagMap, ok := autoTag.(map[string]interface{}); ok {
						if name, exists := autoTagMap["name"]; exists {
							if !existingTagNames[name.(string)] {
								swagTagsList = append(swagTagsList, autoTag)
							}
						}
					}
				}
				mergedSpec["tags"] = swagTagsList
			}
		}
	} else if autoTags != nil {
		mergedSpec["tags"] = autoTags
	}
}

// addMergeMetadata ajoute des informations sur le processus de merge
func (sm *SwaggerSpecMerger) addMergeMetadata(mergedSpec map[string]interface{}) {
	if info, exists := mergedSpec["info"]; exists {
		if infoMap, ok := info.(map[string]interface{}); ok {
			// Ajouter une note dans la description
			if desc, exists := infoMap["description"]; exists {
				infoMap["description"] = fmt.Sprintf("%s\n\nü§ñ Cette documentation combine les annotations manuelles et la g√©n√©ration automatique d'entit√©s.", desc)
			}

			// Ajouter des extensions custom
			infoMap["x-merge-info"] = map[string]interface{}{
				"auto-generated-entities": len(ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs()),
				"generation-time":         "runtime",
			}
		}
	}
}

func (sm *SwaggerSpecMerger) getOrCreateComponents(spec map[string]interface{}) map[string]interface{} {
	if components := sm.getComponents(spec); components != nil {
		return components
	}

	components := make(map[string]interface{})
	spec["components"] = components
	return components
}

func (sm *SwaggerSpecMerger) getOrCreateSchemas(components map[string]interface{}) map[string]interface{} {
	if schemas, exists := components["schemas"]; exists {
		if schemasMap, ok := schemas.(map[string]interface{}); ok {
			return schemasMap
		}
	}

	schemas := make(map[string]interface{})
	components["schemas"] = schemas
	return schemas
}

func (sm *SwaggerSpecMerger) getTags(spec map[string]interface{}) interface{} {
	if tags, exists := spec["tags"]; exists {
		return tags
	}
	return nil
}

func (sm *SwaggerSpecMerger) deepCopy(original map[string]interface{}) map[string]interface{} {
	copy := make(map[string]interface{})
	for key, value := range original {
		copy[key] = value
	}
	return copy
}

// SwaggerMergeMiddleware permet d'exposer la spec merg√©e
func SwaggerMergeMiddleware() func() map[string]interface{} {
	merger := NewSwaggerSpecMerger()

	return func() map[string]interface{} {
		return merger.MergeSpecs()
	}
}
