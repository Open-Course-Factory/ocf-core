package initialization

import (
	"log"
	"net/http"
	"os"
	"time"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"gorm.io/gorm"

	"soli/formations/docs"
	authController "soli/formations/src/auth"
	ems "soli/formations/src/entityManagement/entityManagementService"
	entityManagementInterfaces "soli/formations/src/entityManagement/interfaces"
	swaggerGenerator "soli/formations/src/entityManagement/swagger"
	"soli/formations/src/utils"
)

// InitSwagger initializes Swagger documentation
func InitSwagger(r *gin.Engine, db *gorm.DB) {
	env := os.Getenv("ENVIRONMENT")
	if env == "development" || env == "test" {
		docs.SwaggerInfo.Schemes = []string{"http", "https"}
	} else {
		docs.SwaggerInfo.Schemes = []string{"https"}
	}

	docs.SwaggerInfo.Title = "OCF API"
	docs.SwaggerInfo.Description = "This is an API to build and generate courses with labs"
	docs.SwaggerInfo.Version = getVersionFromFile()

	// Setup de la documentation compl√®te (manual + auto-generated)
	SetupCompleteSwaggerSystem(r, db)
}

func getVersionFromFile() string {
	if data, err := os.ReadFile("VERSION"); err == nil {
		return string(data)
	}
	if version := os.Getenv("OCF_VERSION"); version != "" {
		return version
	}
	return "unknown"
}

// SetupCompleteSwaggerSystem sets up the complete Swagger documentation system
func SetupCompleteSwaggerSystem(r *gin.Engine, db *gorm.DB) {
	log.Println("üöÄ Setting up complete Swagger documentation system...")

	// Middleware d'authentification pour les routes document√©es
	authMiddleware := authController.NewAuthMiddleware(db)

	// üìã √âTAPE 1: Setup des routes auto-document√©es
	log.Println("  üìã Setting up auto-documented routes...")
	routeGenerator := swaggerGenerator.NewSwaggerRouteGenerator(db)
	docGroup := r.Group("/api/v1")
	routeGenerator.RegisterDocumentedRoutes(docGroup, authMiddleware.AuthManagement())

	// üîÄ √âTAPE 2: Setup du merger Swagger
	log.Println("  üîÄ Setting up Swagger spec merger...")
	merger := swaggerGenerator.NewSwaggerSpecMerger()

	// üìÑ √âTAPE 3: Endpoints de documentation
	setupSwaggerEndpoints(r, merger)

	// üìä √âTAPE 4: Endpoints de debug et statistiques
	setupDocumentationDebugEndpoints(r)

	log.Println("‚úÖ Complete Swagger system ready!")
	log.Println("üìö Available endpoints:")
	log.Println("  üé® /swagger/ - Complete documentation (manual + auto)")
	log.Println("  üìã /api/v1/swagger/spec - Merged OpenAPI spec")
	log.Println("  üîç /api/v1/swagger/debug - Debug merge process")
	log.Println("  üìä /api/v1/swagger/stats - Documentation statistics")
	log.Println("  üìÑ /swagger/index.html - Original swag documentation")
}

func setupSwaggerEndpoints(r *gin.Engine, merger *swaggerGenerator.SwaggerSpecMerger) {
	// Endpoint principal : spec merg√©e
	r.GET("/api/v1/swagger/spec", func(ctx *gin.Context) {
		mergedSpec := merger.MergeSpecs()

		// Headers CORS pour Swagger UI
		ctx.Header("Access-Control-Allow-Origin", "*")
		ctx.Header("Access-Control-Allow-Methods", "GET")
		ctx.Header("Access-Control-Allow-Headers", "Content-Type")

		ctx.JSON(http.StatusOK, mergedSpec)
	})

	// Interface Swagger UI personnalis√©e (documentation compl√®te)
	r.GET("/swagger/", func(ctx *gin.Context) {
		ctx.Header("Content-Type", "text/html")
		ctx.String(http.StatusOK, generateCustomSwaggerHTML())
	})

	// Garder l'endpoint original pour compatibilit√©
	r.GET("/swagger/previous", ginSwagger.WrapHandler(swaggerFiles.Handler))
}

func setupDocumentationDebugEndpoints(r *gin.Engine) {
	// Debug: comparer les sources de documentation
	r.GET("/api/v1/swagger/debug", func(ctx *gin.Context) {
		autoSpec := swaggerGenerator.NewDocumentationGenerator().GenerateOpenAPISpec()
		swaggerConfigs := ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs()

		debugInfo := map[string]interface{}{
			"auto_generated_spec":  autoSpec,
			"documented_entities":  len(swaggerConfigs),
			"entity_details":       swaggerConfigs,
			"generation_timestamp": time.Now().Format(time.RFC3339),
			"merge_strategy":       "manual_priority_over_auto",
		}

		ctx.JSON(http.StatusOK, debugInfo)
	})

	// Statistiques de documentation
	r.GET("/api/v1/swagger/stats", func(ctx *gin.Context) {
		swaggerConfigs := ems.GlobalEntityRegistrationService.GetAllSwaggerConfigs()

		stats := map[string]interface{}{
			"total_documented_entities": len(swaggerConfigs),
			"entities_with_swagger":     getEntitiesWithSwagger(swaggerConfigs),
			"auto_generated_routes":     countAutoGeneratedRoutes(swaggerConfigs),
			"documentation_coverage":    calculateDocumentationCoverage(swaggerConfigs),
			"generation_time":           time.Now().Format(time.RFC3339),
		}

		ctx.JSON(http.StatusOK, stats)
	})
}

// generateCustomSwaggerHTML g√©n√®re une page HTML Swagger UI personnalis√©e
func generateCustomSwaggerHTML() string {
	return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OCF API Documentation - Complete</title>
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui.css" />
    <style>
        html { box-sizing: border-box; overflow: -moz-scrollbars-vertical; overflow-y: scroll; }
        *, *:before, *:after { box-sizing: inherit; }
        body { margin:0; background: #fafafa; }

        .header-banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header-banner h1 {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .header-banner p {
            margin: 5px 0 0 0;
            opacity: 0.9;
            font-size: 14px;
        }

        .status-badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 10px;
        }

        /* Style pour les entit√©s auto-g√©n√©r√©es */
        .swagger-ui .opblock.opblock-get .opblock-summary-control,
        .swagger-ui .opblock.opblock-post .opblock-summary-control,
        .swagger-ui .opblock.opblock-patch .opblock-summary-control,
        .swagger-ui .opblock.opblock-delete .opblock-summary-control {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="header-banner">
        <h1>üöÄ OCF API Documentation</h1>
        <p>Documentation compl√®te : Endpoints manuels + Entit√©s auto-g√©n√©r√©es <span class="status-badge">ü§ñ Hybrid</span></p>
    </div>

    <div id="swagger-ui"></div>

    <script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-bundle.js"></script>
    <script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-standalone-preset.js"></script>
    <script>
        window.onload = function() {
            const ui = SwaggerUIBundle({
                url: window.location.origin + '/api/v1/swagger/spec',
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout",
                defaultModelsExpandDepth: 1,
                defaultModelExpandDepth: 1,
                docExpansion: "list",
                tagsSorter: "alpha",
                operationsSorter: "alpha",
                filter: true,
                validatorUrl: null,
                tryItOutEnabled: true,
                onComplete: function() {
                    console.log('üìö OCF API Documentation charg√©e');
                    console.log('üîÄ Documentation hybride : manuelle + auto-g√©n√©r√©e');

										// üîç DEBUG : V√©rifier les serveurs configur√©s
                    const spec = ui.getSystem().specSelectors.spec().toJS();
                    console.log('üîç Servers in spec:', spec.servers);

                    // Ajouter un indicateur de statut dans le header
                    setTimeout(() => {
                        const infoSection = document.querySelector('.information-container');
                        if (infoSection) {
                            const statusDiv = document.createElement('div');
                            statusDiv.style.cssText = 'background: #e8f5e8; padding: 10px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #28a745;';
                            statusDiv.innerHTML = '<strong>üîÑ Documentation dynamique :</strong> Cette documentation est g√©n√©r√©e automatiquement et reste toujours synchronis√©e avec le code.';
                            infoSection.appendChild(statusDiv);
                        }
                    }, 1000);
                }
            });
        };
    </script>
</body>
</html>`
}

func getEntitiesWithSwagger(configs map[string]*entityManagementInterfaces.EntitySwaggerConfig) []string {
	var entities []string
	for entityName := range configs {
		entities = append(entities, entityName)
	}
	return entities
}

func countAutoGeneratedRoutes(configs map[string]*entityManagementInterfaces.EntitySwaggerConfig) int {
	count := 0
	for _, config := range configs {
		if config.GetAll != nil {
			count++
		}
		if config.GetOne != nil {
			count++
		}
		if config.Create != nil {
			count++
		}
		if config.Update != nil {
			count++
		}
		if config.Delete != nil {
			count++
		}
	}
	return count
}

func calculateDocumentationCoverage(configs map[string]*entityManagementInterfaces.EntitySwaggerConfig) map[string]interface{} {
	totalConfigs := len(configs)

	coverage := map[string]interface{}{
		"total_entities":      totalConfigs,
		"coverage_percentage": 100.0, // Toutes les entit√©s enregistr√©es sont document√©es
		"breakdown": map[string]int{
			"get_all_implemented": 0,
			"get_one_implemented": 0,
			"create_implemented":  0,
			"update_implemented":  0,
			"delete_implemented":  0,
		},
	}

	breakdown, ok := coverage["breakdown"].(map[string]int)
	if !ok {
		// This should never happen since we just created the map, but handle it safely
		utils.Error("Failed to type assert breakdown map in coverage calculation")
		return coverage
	}

	for _, config := range configs {
		if config.GetAll != nil {
			breakdown["get_all_implemented"]++
		}
		if config.GetOne != nil {
			breakdown["get_one_implemented"]++
		}
		if config.Create != nil {
			breakdown["create_implemented"]++
		}
		if config.Update != nil {
			breakdown["update_implemented"]++
		}
		if config.Delete != nil {
			breakdown["delete_implemented"]++
		}
	}

	return coverage
}
